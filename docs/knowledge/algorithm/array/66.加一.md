# [LeetCode 66.加一](https://leetcode-cn.com/problems/plus-one)
## 描述

给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:

输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
示例 2:

输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。

## 解一 [进位]
**思路**

最开始看到这题 直接想到的是 转换为数字+1后转回数组

这种方式一行代码写法:

```return String(Number(digits.join(''))+1).split("");```

但是如果数组长度较大也就是数字过大时超过(2的53次方 9007199254740992)js出现不精确的问题所以解决不了大数字的加一

我们采取从后往前进位 即 后一位如果大于9则前一位+1

需要注意的是如果 出现 [9,9,9,9] 我们需要在最前面添加一位数字1 即结果为 [1,0,0,0,0]

**代码**
```Javascript 
var plusOne = function(digits) {
    for(let i = digits.length-1; i >= 0; i--) { // 从后往前遍历
        digits[i]++; // 末尾+1
        if(digits[i] < 10) { // 当前位是否小于10 即不满足进位操作 直接返回digits
            return digits;
        }
        // 到这则表示digits[i] = 10 需要进位 进位后 当前位置（digits[i]） 应该为0
        digits[i] = 0;
    }
    // 如果首位还需要进位 
    digits.unshift(1);
    return digits;
};
```
