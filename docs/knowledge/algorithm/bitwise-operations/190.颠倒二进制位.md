# [LeetCode 190.颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits)
## 描述

颠倒给定的 32 位无符号整数的二进制位。

示例 1：

```
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```
示例 2：
```

输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。
```

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

### 解一 [暴力解法]
**思路**

不使用位操作的解法

转二进制字符串后翻转 最后转十进制数字返回

**代码**
```Javascript 
var reverseBits = function(n) {
    let str = n.toString(2);
    let res = '';
    for(let i = 0,len = str.length-1; i < 32; i++) {
        res += str[len-i] || '0'; // 如果当前位不存在即最前的二进制未默认为0  例：43261596.toString(2)  ==> 10100101000001111010011100
    }
    return parseInt(res,2);
};
```
### 解二 [使用位运算符]
**思路**

每次循环时获取n二进制位的最后一位 并把当前位翻转到 res最前位

**代码**
```Javascript 
var reverseBits = function(n) {
    let res = 0;
    for(let i = 0; i < 32; i++) {
        let lastBits = n & 1; // 取n二进制最后一位
        // lastBits << (31-i) 向左移动对应位 最后与 当前值相加
        res = res + Math.abs((lastBits << (31-i))); // 由于当前32位二进制的最高位为1时会变成负数 且题中都为无符号整数 所以直接取绝对值
        n = n >>> 1; // 当前位已经翻转 移除当前位
    }
    return res;
};
```
