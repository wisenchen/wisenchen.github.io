
### 原题
每个非负整数 N 都有其二进制表示。例如， 5 可以被表示为二进制 "101"，11 可以用二进制 "1011" 表示，依此类推。注意，除 N = 0 外，任何二进制表示中都不含前导零。
二进制的反码表示是将每个 1 改为 0 且每个 0 变为 1。例如，二进制数 "101" 的二进制反码为 "010"。

给定十进制数 N，返回其二进制表示的反码所对应的十进制整数。

<br/>

示例 1：

输入：5

输出：2

解释：5 的二进制表示为 "101"，其二进制反码为 "010"，也就是十进制中的 2 。

<br/>

示例 2：
 
输入：7

输出：0

解释：7 的二进制表示为 "111"，其二进制反码为 "000"，也就是十进制中的 0 。

<br/>

示例 3：

输入：10

输出：5

解释：10 的二进制表示为 "1010"，其二进制反码为 "0101"，也就是十进制中的 5 。
 
<br/>

提示：

0 <= N < 10^9


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/complement-of-base-10-integer

#### 方法一 ($)
 **思路**
    转二进制后把 1替换成0   0替换成1  之后转回十进制即可

**JavaScript代码**
```PowerShell
var bitwiseComplement1 = function (N) {
    return parseInt(N.toString(2).replace(/[(1)|(0)]/g, a => (a == "1" ? "0" : "1")), 2);
 };
```
#### 方法二
**思路**
转二进制后获取长度 同时创建一个长度相同且各位都为1的数转十进制后使用异或运算
例: n = 8
1. 转二进制 8 => 1000
2. 创建长度相同且各位都为1的数s = 1111
3. 转十进制后使用异或运算 ^   即8 ^ 15

**JavaScript代码**
```PowerShell
var bitwiseComplement2 = function (N) {
   var s = N.toString(2), // 转二进制
       s1 = "",          
       len = s.length;
    while (len) {// 循环创建 1111。。。字符串
        len--;
        s1 += "1";
    } 
    return parseInt(s, 2) ^ parseInt(s1, 2); // 这里可以直接使用  s1 - s 
};
```
#### 方法三
**思路**
方法二的优化 利用<< 左位移与 10 、110 ... ^1  => 11、111来实现创建与n二进制数长度相同的111..
**JavaScript代码**
```PowerShell
var bitwiseComplement3 = function (N) {
    var i = 1;
    while (i < N) {
        i = (i << 1) ^ 1; // 二进制数末尾加一个0后在变为1 即可保持i的二进制一直都是类似11111...
    }
    return i - N;
};
```

